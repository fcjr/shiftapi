import type { Plugin, ViteDevServer } from "vite";
import { resolve, relative } from "node:path";
import {
  writeFileSync,
  readFileSync,
  mkdirSync,
  existsSync,
} from "node:fs";
import { spawn, type ChildProcess } from "node:child_process";
import { createServer as createTcpServer } from "node:net";
import { extractSpec } from "./extract.js";
import { generateTypes } from "./generate.js";
import { buildVirtualModuleSource } from "./virtualModule.js";
import type { ShiftAPIPluginOptions } from "./types.js";

const MODULE_ID = "@shiftapi/client";
const RESOLVED_MODULE_ID = "\0" + MODULE_ID;

function isPortFree(port: number): Promise<boolean> {
  return new Promise((resolve) => {
    const server = createTcpServer();
    server.once("error", () => resolve(false));
    server.once("listening", () => {
      server.close(() => resolve(true));
    });
    server.listen(port);
  });
}

async function findFreePort(startPort: number): Promise<number> {
  for (let port = startPort; port < startPort + 20; port++) {
    if (await isPortFree(port)) return port;
  }
  return startPort;
}

export default function shiftapiPlugin(options: ShiftAPIPluginOptions): Plugin {
  const {
    server: serverEntry,
    baseUrl = "/",
    goRoot = process.cwd(),
    url = "http://localhost:8080",
  } = options;

  const parsedUrl = new URL(url);
  const basePort = parseInt(parsedUrl.port || "8080");
  let goPort = basePort;

  let virtualModuleSource = "";
  let generatedDts = "";
  let cachedSpec: Record<string, unknown> | null = null;
  let devServer: ViteDevServer | undefined;
  let goProcess: ChildProcess | null = null;
  let debounceTimer: ReturnType<typeof setTimeout> | null = null;
  let projectRoot = process.cwd();

  function getSpec(): Record<string, unknown> {
    if (!cachedSpec) {
      cachedSpec = extractSpec(
        serverEntry,
        resolve(goRoot)
      ) as Record<string, unknown>;
    }
    return cachedSpec;
  }

  async function regenerate(): Promise<boolean> {
    cachedSpec = null;
    const spec = getSpec();
    const types = await generateTypes(spec);

    if (types === generatedDts) {
      return false;
    }

    generatedDts = types;
    virtualModuleSource = buildVirtualModuleSource(baseUrl);
    return true;
  }

  function writeDtsFile(): void {
    const outDir = resolve(projectRoot, ".shiftapi");
    if (!existsSync(outDir)) {
      mkdirSync(outDir, { recursive: true });
    }

    const dtsContent = `// Auto-generated by @shiftapi/vite-plugin. Do not edit.
declare module "@shiftapi/client" {
${generatedDts
  .split("\n")
  .map((line) => (line ? "  " + line : line))
  .join("\n")}

  import type createClient from "openapi-fetch";

  export const client: ReturnType<typeof createClient<paths>>;
  export { createClient };
}
`;
    writeFileSync(resolve(outDir, "client.d.ts"), dtsContent);
  }

  function patchTsConfig(): void {
    const tsconfigPath = resolve(projectRoot, "tsconfig.json");
    if (!existsSync(tsconfigPath)) return;

    const raw = readFileSync(tsconfigPath, "utf-8");
    const tsconfig = JSON.parse(raw);

    if (tsconfig?.compilerOptions?.paths?.[MODULE_ID]) return;

    if (!tsconfig.compilerOptions) tsconfig.compilerOptions = {};
    if (!tsconfig.compilerOptions.paths) tsconfig.compilerOptions.paths = {};
    tsconfig.compilerOptions.paths[MODULE_ID] = [
      "./.shiftapi/client.d.ts",
    ];

    const indent = raw.match(/^[ \t]+/m)?.[0] ?? "  ";
    writeFileSync(tsconfigPath, JSON.stringify(tsconfig, null, indent) + "\n");
    console.log(
      "[shiftapi] Updated tsconfig.json with @shiftapi/client path mapping"
    );
  }

  function startGoServer(): void {
    goProcess = spawn("go", ["run", "-tags", "shiftapidev", serverEntry], {
      cwd: resolve(goRoot),
      stdio: ["ignore", "inherit", "inherit"],
      detached: true,
      env: {
        ...process.env,
        SHIFTAPI_PORT: String(goPort),
      },
    });

    goProcess.on("error", (err) => {
      console.error("[shiftapi] Failed to start Go server:", err.message);
    });

    goProcess.on("exit", (code) => {
      if (code !== null && code !== 0) {
        console.error(`[shiftapi] Go server exited with code ${code}`);
      }
      goProcess = null;
    });

    console.log(
      `[shiftapi] Go server starting on port ${goPort}: go run ${serverEntry}`
    );
  }

  function stopGoServer(): Promise<void> {
    const proc = goProcess;
    if (!proc || !proc.pid) return Promise.resolve();

    const pid = proc.pid;
    goProcess = null;

    return new Promise((resolve) => {
      const timeout = setTimeout(() => {
        // Escalate to SIGKILL if SIGTERM didn't work
        try {
          process.kill(-pid, "SIGKILL");
        } catch {
          // already gone
        }
        resolve();
      }, 5000);

      proc.on("exit", () => {
        clearTimeout(timeout);
        resolve();
      });

      // Kill the entire process group so the `go run` child process
      // (the compiled server binary) is also terminated.
      try {
        process.kill(-pid, "SIGTERM");
      } catch {
        // Process group may already be gone
        clearTimeout(timeout);
        resolve();
      }
    });
  }

  return {
    name: "@shiftapi/vite-plugin",

    configResolved(config) {
      projectRoot = config.root;
      patchTsConfig();
    },

    async config(_, env) {
      if (env.command === "serve") {
        goPort = await findFreePort(basePort);
        if (goPort !== basePort) {
          console.log(
            `[shiftapi] Port ${basePort} is in use, using ${goPort}`
          );
        }
      }

      // Extract spec to discover API paths, then auto-configure proxy
      const spec = getSpec();
      const paths = spec.paths as Record<string, unknown> | undefined;
      if (!paths) return;

      const targetUrl = `${parsedUrl.protocol}//${parsedUrl.hostname}:${goPort}`;
      const proxy: Record<string, string> = {};
      for (const path of Object.keys(paths)) {
        proxy[path] = targetUrl;
      }

      return {
        server: { proxy },
      };
    },

    configureServer(server) {
      devServer = server;
      server.watcher.add(resolve(goRoot));

      startGoServer();

      server.httpServer?.on("close", () => {
        stopGoServer().catch((err) => {
          console.error("[shiftapi] Failed to stop Go server on close:", err);
        });
      });
      process.on("exit", () => {
        // exit handler is synchronous; best-effort kill
        if (goProcess?.pid) {
          try {
            process.kill(-goProcess.pid, "SIGTERM");
          } catch {
            // already gone
          }
        }
      });
      process.on("SIGINT", async () => {
        await stopGoServer();
        process.exit();
      });
      process.on("SIGTERM", async () => {
        await stopGoServer();
        process.exit();
      });
    },

    async buildStart() {
      await regenerate();
      writeDtsFile();
    },

    resolveId(id) {
      if (id === MODULE_ID) {
        return RESOLVED_MODULE_ID;
      }
    },

    load(id) {
      if (id === RESOLVED_MODULE_ID) {
        return virtualModuleSource;
      }
    },

    async handleHotUpdate({ file }) {
      const resolvedGoRoot = resolve(goRoot);
      if (!file.endsWith(".go") || !file.startsWith(resolvedGoRoot)) {
        return;
      }

      console.log(
        `[shiftapi] Go file changed: ${relative(resolvedGoRoot, file)}`
      );

      if (debounceTimer) clearTimeout(debounceTimer);
      debounceTimer = setTimeout(async () => {
        try {
          // Restart Go server with new code
          await stopGoServer();
          startGoServer();

          const changed = await regenerate();
          if (changed && devServer) {
            writeDtsFile();
            const mod =
              devServer.moduleGraph.getModuleById(RESOLVED_MODULE_ID);
            if (mod) {
              devServer.moduleGraph.invalidateModule(mod);
              devServer.ws.send({ type: "full-reload" });
            }
            console.log("[shiftapi] Types regenerated.");
          }
        } catch (err) {
          console.error("[shiftapi] Failed to regenerate:", err);
        }
      }, 500);
    },
  };
}

export type { ShiftAPIPluginOptions };
