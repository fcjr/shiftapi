import type { Plugin, ViteDevServer } from "vite";
import { resolve, relative } from "node:path";
import {
  writeFileSync,
  readFileSync,
  mkdirSync,
  existsSync,
} from "node:fs";
import { createRequire } from "node:module";
import { spawn, type ChildProcess } from "node:child_process";
import { createServer as createTcpServer } from "node:net";
import { extractSpec } from "./extract.js";
import { generateTypes } from "./generate.js";
import { buildVirtualModuleSource } from "./virtualModule.js";
import type { ShiftAPIPluginOptions } from "./types.js";

const pluginRequire = createRequire(import.meta.url);

const MODULE_ID = "@shiftapi/client";
const RESOLVED_MODULE_ID = "\0" + MODULE_ID;
const DEV_API_PREFIX = "/__shiftapi";

function isPortFree(port: number): Promise<boolean> {
  return new Promise((resolve) => {
    const server = createTcpServer();
    server.once("error", () => resolve(false));
    server.once("listening", () => {
      server.close(() => resolve(true));
    });
    server.listen(port);
  });
}

async function findFreePort(startPort: number): Promise<number> {
  for (let port = startPort; port < startPort + 20; port++) {
    if (await isPortFree(port)) return port;
  }
  console.warn(
    `[shiftapi] No free port found in range ${startPort}-${startPort + 19}, falling back to ${startPort}`
  );
  return startPort;
}

export default function shiftapiPlugin(options: ShiftAPIPluginOptions): Plugin {
  const {
    server: serverEntry,
    baseUrl = "/",
    goRoot = process.cwd(),
    url = "http://localhost:8080",
  } = options;

  const parsedUrl = new URL(url);
  const basePort = parseInt(parsedUrl.port || "8080");
  let goPort = basePort;

  let virtualModuleSource = "";
  let generatedDts = "";
  let cachedSpec: Record<string, unknown> | null = null;
  let devServer: ViteDevServer | undefined;
  let goProcess: ChildProcess | null = null;
  let debounceTimer: ReturnType<typeof setTimeout> | null = null;
  let projectRoot = process.cwd();
  let isDev = false;

  function getSpec(): Record<string, unknown> {
    if (!cachedSpec) {
      cachedSpec = extractSpec(
        serverEntry,
        resolve(goRoot)
      ) as Record<string, unknown>;
    }
    return cachedSpec;
  }

  async function regenerate(): Promise<boolean> {
    cachedSpec = null;
    const spec = getSpec();
    const types = await generateTypes(spec);

    if (types === generatedDts) {
      return false;
    }

    generatedDts = types;
    virtualModuleSource = buildVirtualModuleSource(
      baseUrl,
      isDev ? DEV_API_PREFIX : undefined
    );
    return true;
  }

  function writeDtsFile(): void {
    const outDir = resolve(projectRoot, ".shiftapi");
    if (!existsSync(outDir)) {
      mkdirSync(outDir, { recursive: true });
    }

    const dtsContent = `// Auto-generated by @shiftapi/vite-plugin. Do not edit.
declare module "@shiftapi/client" {
${generatedDts
  .split("\n")
  .map((line) => (line ? "  " + line : line))
  .join("\n")}

  import type createClient from "openapi-fetch";

  export const client: ReturnType<typeof createClient<paths>>;
  export { createClient };
}
`;
    writeFileSync(resolve(outDir, "client.d.ts"), dtsContent);
  }

  function patchTsConfig(): void {
    const tsconfigPath = resolve(projectRoot, "tsconfig.json");
    if (!existsSync(tsconfigPath)) return;

    const raw = readFileSync(tsconfigPath, "utf-8");
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    let tsconfig: any;
    try {
      tsconfig = JSON.parse(raw);
    } catch (err) {
      console.warn(
        `[shiftapi] Failed to parse tsconfig.json: ${err instanceof Error ? err.message : String(err)}`
      );
      return;
    }

    if (tsconfig?.compilerOptions?.paths?.[MODULE_ID]) return;

    if (!tsconfig.compilerOptions) tsconfig.compilerOptions = {};
    if (!tsconfig.compilerOptions.paths) tsconfig.compilerOptions.paths = {};
    tsconfig.compilerOptions.paths[MODULE_ID] = [
      "./.shiftapi/client.d.ts",
    ];

    const indent = raw.match(/^[ \t]+/m)?.[0] ?? "  ";
    writeFileSync(tsconfigPath, JSON.stringify(tsconfig, null, indent) + "\n");
    console.log(
      "[shiftapi] Updated tsconfig.json with @shiftapi/client path mapping"
    );
  }

  function startGoServer(): Promise<void> {
    return new Promise((resolveStart, rejectStart) => {
      const proc = spawn("go", ["run", "-tags", "shiftapidev", serverEntry], {
        cwd: resolve(goRoot),
        stdio: ["ignore", "inherit", "inherit"],
        detached: true,
        env: {
          ...process.env,
          SHIFTAPI_PORT: String(goPort),
        },
      });
      goProcess = proc;

      let settled = false;

      proc.on("error", (err) => {
        console.error("[shiftapi] Failed to start Go server:", err.message);
        if (!settled) {
          settled = true;
          rejectStart(err);
        }
      });

      proc.on("exit", (code) => {
        if (code !== null && code !== 0) {
          console.error(`[shiftapi] Go server exited with code ${code}`);
        }
        goProcess = null;
      });

      // Consider started once the process has been spawned (has a pid)
      proc.on("spawn", () => {
        if (!settled) {
          settled = true;
          resolveStart();
        }
      });

      console.log(
        `[shiftapi] Go server starting on port ${goPort}: go run ${serverEntry}`
      );
    });
  }

  function stopGoServer(): Promise<void> {
    const proc = goProcess;
    if (!proc || !proc.pid) return Promise.resolve();

    const pid = proc.pid;
    goProcess = null;

    return new Promise((resolve) => {
      const timeout = setTimeout(() => {
        // Escalate to SIGKILL if SIGTERM didn't work
        try {
          process.kill(-pid, "SIGKILL");
        } catch {
          // already gone
        }
        resolve();
      }, 5000);

      proc.on("exit", () => {
        clearTimeout(timeout);
        resolve();
      });

      // Kill the entire process group so the `go run` child process
      // (the compiled server binary) is also terminated.
      try {
        process.kill(-pid, "SIGTERM");
      } catch {
        // Process group may already be gone
        clearTimeout(timeout);
        resolve();
      }
    });
  }

  return {
    name: "@shiftapi/vite-plugin",

    configResolved(config) {
      projectRoot = config.root;
      patchTsConfig();
    },

    async config(_, env) {
      if (env.command === "serve") {
        isDev = true;
        goPort = await findFreePort(basePort);
        if (goPort !== basePort) {
          console.log(
            `[shiftapi] Port ${basePort} is in use, using ${goPort}`
          );
        }

        const targetUrl = `${parsedUrl.protocol}//${parsedUrl.hostname}:${goPort}`;
        return {
          server: {
            proxy: {
              [DEV_API_PREFIX]: {
                target: targetUrl,
                rewrite: (path: string) =>
                  path.replace(new RegExp(`^${DEV_API_PREFIX}`), "") || "/",
              },
            },
          },
        };
      }
    },

    configureServer(server) {
      devServer = server;
      server.watcher.add(resolve(goRoot));

      startGoServer()
        .then(() => {
          console.log(
            `[shiftapi] API docs available at http://localhost:${goPort}/docs`
          );
        })
        .catch((err) => {
          console.error("[shiftapi] Go server failed to start:", err);
        });

      function clearDebounce() {
        if (debounceTimer) {
          clearTimeout(debounceTimer);
          debounceTimer = null;
        }
      }

      server.httpServer?.on("close", () => {
        clearDebounce();
        stopGoServer().catch((err) => {
          console.error("[shiftapi] Failed to stop Go server on close:", err);
        });
      });
      process.on("exit", () => {
        clearDebounce();
        // exit handler is synchronous; best-effort kill
        if (goProcess?.pid) {
          try {
            process.kill(-goProcess.pid, "SIGTERM");
          } catch {
            // already gone
          }
        }
      });
      process.on("SIGINT", async () => {
        clearDebounce();
        await stopGoServer();
        process.exit();
      });
      process.on("SIGTERM", async () => {
        clearDebounce();
        await stopGoServer();
        process.exit();
      });
    },

    async buildStart() {
      await regenerate();
      writeDtsFile();
    },

    resolveId(id, importer) {
      if (id === MODULE_ID) {
        return RESOLVED_MODULE_ID;
      }
      // Resolve openapi-fetch from the plugin's own node_modules so
      // consuming projects don't need to install it directly.
      if (id === "openapi-fetch" && importer === RESOLVED_MODULE_ID) {
        return pluginRequire.resolve("openapi-fetch");
      }
    },

    load(id) {
      if (id === RESOLVED_MODULE_ID) {
        return virtualModuleSource;
      }
    },

    async handleHotUpdate({ file }) {
      const resolvedGoRoot = resolve(goRoot);
      if (!file.endsWith(".go") || !file.startsWith(resolvedGoRoot)) {
        return;
      }

      console.log(
        `[shiftapi] Go file changed: ${relative(resolvedGoRoot, file)}`
      );

      if (debounceTimer) clearTimeout(debounceTimer);
      debounceTimer = setTimeout(async () => {
        try {
          // Restart Go server with new code
          await stopGoServer();
          await startGoServer();

          const changed = await regenerate();
          if (changed && devServer) {
            writeDtsFile();
            const mod =
              devServer.moduleGraph.getModuleById(RESOLVED_MODULE_ID);
            if (mod) {
              devServer.moduleGraph.invalidateModule(mod);
              devServer.ws.send({ type: "full-reload" });
            }
            console.log("[shiftapi] Types regenerated.");
          }
        } catch (err) {
          console.error("[shiftapi] Failed to regenerate:", err);
        }
      }, 500);
    },
  };
}

export type { ShiftAPIPluginOptions };
