import type { Plugin, ViteDevServer } from "vite";
import { resolve, relative } from "node:path";
import { writeFileSync, mkdirSync, existsSync } from "node:fs";
import { spawn, type ChildProcess } from "node:child_process";
import { extractSpec } from "./extract.js";
import { generateTypes } from "./generate.js";
import { buildVirtualModuleSource } from "./virtualModule.js";
import type { ShiftAPIPluginOptions } from "./types.js";

const MODULE_ID = "@shiftapi/client";
const RESOLVED_MODULE_ID = "\0" + MODULE_ID;

export default function shiftapiPlugin(options: ShiftAPIPluginOptions): Plugin {
  const {
    server: serverEntry,
    baseUrl = "/",
    goRoot = process.cwd(),
    url = "http://localhost:8080",
  } = options;

  let virtualModuleSource = "";
  let generatedDts = "";
  let cachedSpec: Record<string, unknown> | null = null;
  let devServer: ViteDevServer | undefined;
  let goProcess: ChildProcess | null = null;
  let debounceTimer: ReturnType<typeof setTimeout> | null = null;

  function getSpec(): Record<string, unknown> {
    if (!cachedSpec) {
      cachedSpec = extractSpec(
        serverEntry,
        resolve(goRoot)
      ) as Record<string, unknown>;
    }
    return cachedSpec;
  }

  async function regenerate(): Promise<boolean> {
    cachedSpec = null;
    const spec = getSpec();
    const types = await generateTypes(spec);

    if (types === generatedDts) {
      return false;
    }

    generatedDts = types;
    virtualModuleSource = buildVirtualModuleSource(baseUrl);
    return true;
  }

  function writeDtsFile(): void {
    const outDir = resolve("node_modules", ".shiftapi");
    if (!existsSync(outDir)) {
      mkdirSync(outDir, { recursive: true });
    }

    const dtsContent = `// Auto-generated by @shiftapi/vite-plugin. Do not edit.
declare module "@shiftapi/client" {
${generatedDts
  .split("\n")
  .map((line) => (line ? "  " + line : line))
  .join("\n")}

  import type createClient from "openapi-fetch";

  export const client: ReturnType<typeof createClient<paths>>;
  export { createClient };
}
`;
    writeFileSync(resolve(outDir, "client.d.ts"), dtsContent);
  }

  function startGoServer(): void {
    goProcess = spawn("go", ["run", serverEntry], {
      cwd: resolve(goRoot),
      stdio: ["ignore", "inherit", "inherit"],
    });

    goProcess.on("error", (err) => {
      console.error("[shiftapi] Failed to start Go server:", err.message);
    });

    goProcess.on("exit", (code) => {
      if (code !== null && code !== 0) {
        console.error(`[shiftapi] Go server exited with code ${code}`);
      }
      goProcess = null;
    });

    console.log(`[shiftapi] Go server starting: go run ${serverEntry}`);
  }

  function stopGoServer(): void {
    if (goProcess) {
      goProcess.kill();
      goProcess = null;
    }
  }

  return {
    name: "@shiftapi/vite-plugin",

    config() {
      // Extract spec to discover API paths, then auto-configure proxy
      const spec = getSpec();
      const paths = spec.paths as Record<string, unknown> | undefined;
      if (!paths) return;

      const proxy: Record<string, string> = {};
      for (const path of Object.keys(paths)) {
        proxy[path] = url;
      }

      return {
        server: { proxy },
      };
    },

    configureServer(server) {
      devServer = server;
      server.watcher.add(resolve(goRoot));

      startGoServer();

      server.httpServer?.on("close", stopGoServer);
    },

    async buildStart() {
      await regenerate();
      writeDtsFile();
    },

    resolveId(id) {
      if (id === MODULE_ID) {
        return RESOLVED_MODULE_ID;
      }
    },

    load(id) {
      if (id === RESOLVED_MODULE_ID) {
        return virtualModuleSource;
      }
    },

    async handleHotUpdate({ file }) {
      const resolvedGoRoot = resolve(goRoot);
      if (!file.endsWith(".go") || !file.startsWith(resolvedGoRoot)) {
        return;
      }

      console.log(
        `[shiftapi] Go file changed: ${relative(resolvedGoRoot, file)}`
      );

      if (debounceTimer) clearTimeout(debounceTimer);
      debounceTimer = setTimeout(async () => {
        try {
          // Restart Go server with new code
          stopGoServer();
          startGoServer();

          const changed = await regenerate();
          if (changed && devServer) {
            writeDtsFile();
            const mod =
              devServer.moduleGraph.getModuleById(RESOLVED_MODULE_ID);
            if (mod) {
              devServer.moduleGraph.invalidateModule(mod);
              devServer.ws.send({ type: "full-reload" });
            }
            console.log("[shiftapi] Types regenerated.");
          }
        } catch (err) {
          console.error("[shiftapi] Failed to regenerate:", err);
        }
      }, 500);
    },
  };
}

export type { ShiftAPIPluginOptions };
